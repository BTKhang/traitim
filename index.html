<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Heart Animation With Password (Mobile-friendly)</title>
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
<style>
  html,body{
    margin:0; padding:0; height:100%; background:#000; overflow:hidden;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* login box */
  #loginBox{
    position:fixed; left:50%; top:50%;
    transform:translate(-50%,-50%);
    background: rgba(255,255,255,0.08);
    padding:22px; border-radius:12px;
    box-shadow:0 6px 30px rgba(255,0,150,0.25);
    text-align:center; backdrop-filter: blur(6px);
  }
  #loginBox h2{ color:#fff; font-family:'Great Vibes'; font-size:36px; margin:0 0 12px; }
  #loginBox input{
    padding:10px 12px; border-radius:8px; border:none; outline:none;
    width:200px; text-align:center; font-size:16px;
  }
  #loginBox button{
    margin-top:10px; padding:9px 20px; border-radius:8px; border:none; cursor:pointer;
    background:#ff4fa6; color:white; font-weight:700;
  }
  #wrongPass{ color:#ff8080; margin-top:8px; display:none; }

  /* wrapper centers canvas and scales on small screens */
  #wrapper{
    position:fixed; left:50%; top:50%;
    transform-origin:center center;
    pointer-events:none; /* allow input when login visible */
  }

  canvas{
    display:block;
    width:100vw; height:100vh;
    background:transparent;
    pointer-events:auto;
  }

  /* mobile tweaks */
  @media (max-width:600px){
    #loginBox h2{ font-size:30px; }
    #loginBox input{ width:150px; font-size:15px; }
    #loginBox{ padding:16px; }
  }
</style>
</head>
<body>

<div id="loginBox">
  <h2>Nhập mật khẩu đi emmm</h2>
  <input id="passInput" type="password" placeholder="••••••" />
  <div>
    <button onclick="checkPass()">OK</button>
  </div>
  <div id="wrongPass">Sai mật khẩu!</div>
</div>

<div id="wrapper">
  <canvas id="heart"></canvas>
</div>

<script>
/* ================= PASSWORD ================== */
const PASSWORD = "161227";
function checkPass(){
  const input = document.getElementById("passInput").value;
  const wrong = document.getElementById("wrongPass");
  if(input === PASSWORD){
    document.getElementById("loginBox").style.display = "none";
    document.getElementById("wrapper").style.pointerEvents = "auto";
    startAnimation();
  } else {
    wrong.style.display = "block";
  }
}

/* ================ RESOURCES ================== */
/* small images must exist: small1.png ... small10.png */
const smallImgs = [];
for(let i=1;i<=10;i++){
  const im = new Image();
  im.src = `small${i}.png`;
  smallImgs.push(im);
}
/* We'll use smallImgs as bigImg source too */
let bigImg = smallImgs[0];
let loadedCount = 0;
smallImgs.forEach(img=>{
  img.onload = ()=>{ loadedCount++; };
});

/* change bigImg every 2s (smooth transition handled later) */
setInterval(()=> {
  const r = Math.floor(Math.random()*smallImgs.length);
  bigImg = smallImgs[r];
}, 2000);

/* ================= CANVAS SETUP ================= */
const wrapper = document.getElementById("wrapper");
const canvas = document.getElementById("heart");
const ctx = canvas.getContext("2d");

let DPR = window.devicePixelRatio || 1;
let W = 0, H = 0;

/* center + scale wrapper for mobile so UI won't overflow */
function updateWrapperScale(){
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let scale = 1;
  if(vw < 500) scale = 0.72;
  else if(vw < 700) scale = 0.84;
  else scale = 1;
  wrapper.style.transform = `translate(-50%,-50%) scale(${scale})`;
}

/* resize hiDPI canvas without distortion */
function resizeCanvas(){
  DPR = window.devicePixelRatio || 1;
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;

  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";

  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);

  ctx.setTransform(DPR,0,0,DPR,0,0); // scale drawing operations
  W = cssW; H = cssH;
  updateWrapperScale();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* responsive params */
function isMobile() { return Math.min(W,H) < 700; }

/* =============== HEART MATH (points) =============== */
function heart(rad){ 
  return [
    Math.pow(Math.sin(rad),3),
    -(15*Math.cos(rad)-5*Math.cos(2*rad)-2*Math.cos(3*rad)-Math.cos(4*rad))
  ];
}
function scalePoint(p,sx,sy,dx,dy){ return [ dx + p[0]*sx, dy + p[1]*sy ]; }

function buildPts(){
  const pts = [];
  const step = isMobile() ? 0.17 : 0.1;
  for(let r=0;r<Math.PI*2;r+=step) pts.push(scalePoint(heart(r), 210, 15, 0, 0));
  for(let r=0;r<Math.PI*2;r+=step) pts.push(scalePoint(heart(r), 150, 10, 0, 0));
  for(let r=0;r<Math.PI*2;r+=step) pts.push(scalePoint(heart(r), 90, 6, 0, 0));
  return pts;
}
let pts = buildPts();
let N = pts.length;
let target = new Array(N);

/* on resize rebuild pts with different density */
window.addEventListener("resize", ()=>{ pts = buildPts(); N = pts.length; target = new Array(N); });

function pulse(kx,ky){
  for(let i=0;i<N;i++){
    target[i] = [ pts[i][0]*kx + W/2, pts[i][1]*ky + H/2 ];
  }
}

/* ============== PARTICLES ============== */
let particles = [];
function createParticles(){
  particles = [];
  const traceLen = isMobile()? 18 : 40;
  for(let i=0;i<N;i++){
    const x = Math.random()*W, y = Math.random()*H;
    const trace = [];
    for(let k=0;k<traceLen;k++) trace.push({x:x,y:y});
    particles.push({
      vx:0, vy:0,
      speed: (Math.random()*1 + (isMobile()?2.5:5)),
      q: Math.floor(Math.random()*N),
      D: Math.random()<0.5 ? -1 : 1,
      force: 0.7 + Math.random()*0.3,
      trace: trace,
      img: smallImgs[Math.floor(Math.random()*smallImgs.length)]
    });
  }
}
createParticles();
window.addEventListener("resize", ()=>{ createParticles(); });

/* ============== TEXT WRAPPING + TYPING ============== */
/* We'll auto-split long messages to fit a max width */
const rawMessages = [
  "Chúc em luôn xinh đẹp và rạng rỡ như hôm nay ♥",
  "Chúc em lúc nào cũng tràn niềm vui và hạnh phúc.",
  "Mong hai chúng ta trải qua bao khó khăn cũng luôn chọn bên nhau.",
  "Cùng ở bên nhau thật lâu nhé cô giáo nhỏ của a ạ ♥"
];

let wrappedMessages = []; // array of single-line strings (already wrapped)
function wrapAllMessages(){
  wrappedMessages = [];
  // temporary canvas context for measuring
  const mctx = document.createElement("canvas").getContext("2d");
  // choose font-size based on screen
  const fontSize = isMobile() ? Math.max(18, Math.floor(Math.min(W,H)*0.025)) : 28;
  const font = `${fontSize}px 'Great Vibes'`;
  mctx.font = font;
  const maxWidth = Math.min(W, 460) * (isMobile() ? 0.9 : 1.0); // leave margin
  rawMessages.forEach(msg=>{
    // split words and greedily fit
    const words = msg.split(" ");
    let line = "";
    for(let w of words){
      const test = line ? (line + " " + w) : w;
      const width = mctx.measureText(test).width;
      if(width > maxWidth && line){
        wrappedMessages.push(line);
        line = w;
      } else {
        line = test;
      }
    }
    if(line) wrappedMessages.push(line);
  });
  // if wrappedMessages empty fallback to raw
  if(wrappedMessages.length===0) wrappedMessages = rawMessages.slice();
}
wrapAllMessages();
window.addEventListener("resize", wrapAllMessages);

/* Typing engine variables */
let lineIndex = 0;
let charIndex = 0;
let typeTimer = 0;
let lineDoneTimer = 0;
const typingSpeed = 0.6; // smaller = faster

/* ============== ANIMATION LOOP ============== */
let bigOpacity = 0;
let time = 0;

function loop(){
  time += 0.016;
  const K = (1 - Math.cos(time)) * 0.5;
  pulse(K,K);

  // background fade to create trails
  ctx.fillStyle = "rgba(0,0,0,0.14)";
  ctx.fillRect(0,0,W,H);

  // draw small particle traces (images)
  const drawSize = isMobile() ? 12 : 16;
  for(let i=0;i<N;i++){
    const p = particles[i];
    const tg = target[p.q];

    // steering
    const dx = p.trace[0].x - tg[0];
    const dy = p.trace[0].y - tg[1];
    const dist = Math.sqrt(dx*dx + dy*dy) + 0.0001;

    if(dist < 10 + (isMobile()?6:0)){
      if(Math.random() > 0.95) p.q = Math.floor(Math.random()*N);
      else {
        if(Math.random() > 0.99) p.D *= -1;
        p.q = (p.q + p.D + N) % N;
      }
    }

    p.vx += -dx/dist * p.speed;
    p.vy += -dy/dist * p.speed;

    p.trace[0].x += p.vx;
    p.trace[0].y += p.vy;

    p.vx *= p.force;
    p.vy *= p.force;

    for(let k=1;k<p.trace.length;k++){
      const T = p.trace[k], P = p.trace[k-1];
      T.x -= 0.4*(T.x - P.x);
      T.y -= 0.4*(T.y - P.y);
    }

    // draw trace images
    for(let k=0;k<p.trace.length;k++){
      const t = p.trace[k];
      if(p.img && p.img.complete){
        ctx.drawImage(p.img, t.x - drawSize/2, t.y - drawSize/2, drawSize, drawSize);
      }
    }
  }

  // big image in center (no clip-path issues): draw below text; keep it constrained
  if(loadedCount >= smallImgs.length){
    if(bigOpacity < 1) bigOpacity += 0.02;
    ctx.save();
    ctx.globalAlpha = bigOpacity;

    // pulse size
    const beat = 1 + Math.sin(time*2) * 0.08;
    const baseSize = Math.min(W,H) * (isMobile()?0.20:0.15);
    const S = baseSize * beat;

    // draw heart-shaped mask then image inside: use clip, but guard with save/restore
    heartPath(ctx, W/2, H/2, S);
    ctx.clip();
    if(bigImg && bigImg.complete){
      // draw fitted in box (preserve aspect ratio)
      const drawW = S*2, drawH = S*2;
      ctx.drawImage(bigImg, W/2 - drawW/2, H/2 - drawH/2, drawW, drawH);
    }
    ctx.restore();
  }

  // TEXT: name + typing text
  ctx.save();
  // name
  const nameFontSize = isMobile()? Math.max(28, Math.floor(Math.min(W,H)*0.045)) : 48;
  ctx.font = `${nameFontSize}px 'Great Vibes'`;
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.shadowColor = "rgba(255,60,140,0.9)";
  ctx.shadowBlur = 8 + Math.sin(time*3)*6;

  const nameY = H/2 + (Math.min(W,H) * (isMobile()?0.28:0.30));
  ctx.fillText("Lê Thị Thu Hằng", W/2, nameY);

  // typing: use wrappedMessages array (each element fits width)
  const msgFontSize = isMobile()? Math.max(14, Math.floor(Math.min(W,H)*0.02)) : 28;
  ctx.font = `${msgFontSize}px 'Great Vibes'`;
  ctx.shadowBlur = 0;

  if(wrappedMessages.length===0) wrapAllMessages(); // safety

  // ensure lineIndex in range
  if(lineIndex >= wrappedMessages.length) lineIndex = 0;
  const curLine = wrappedMessages[lineIndex];

  // timer update
  typeTimer += 0.016 * 60/60; // normalize
  if(charIndex >= curLine.length){
    lineDoneTimer += 0.016;
    if(lineDoneTimer > 1.4){ // 1.4s pause then next line
      lineDoneTimer = 0;
      charIndex = 0;
      lineIndex++;
      if(lineIndex >= wrappedMessages.length) lineIndex = 0;
    }
  } else {
    if(typeTimer > typingSpeed){
      typeTimer = 0;
      charIndex++;
    }
  }

  const visible = curLine.substring(0, charIndex);
  ctx.fillText(visible, W/2, nameY + (isMobile()? (msgFontSize*2.2) : 55) );

  ctx.restore();

  requestAnimationFrame(loop);
}

/* heartPath helper */
function heartPath(ctx, cx, cy, size){
  ctx.beginPath();
  const steps = 120;
  for(let i=0;i<=steps;i++){
    const t = (Math.PI*2)*(i/steps);
    let x = 16*Math.pow(Math.sin(t),3);
    let y = -(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
    x = cx + x*(size/17);
    y = cy + y*(size/17);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
}

/* start animation after login */
function startAnimation(){
  // ensure wrapper visible and scaled
  updateWrapperScale();
  // resize canvas once more to pick DPR etc
  resizeCanvas();
  // build wrapped messages to fit current width
  wrapAllMessages();
  // reset typing
  lineIndex = 0; charIndex = 0; typeTimer = 0; lineDoneTimer = 0;
  // start loop
  requestAnimationFrame(loop);
}

/* initial wrapper scale */
updateWrapperScale();
</script>
</body>
</html>
